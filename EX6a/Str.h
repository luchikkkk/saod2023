#include <string.h>
#include "_str.h"

class Str {
	_str* m_pStr;
public:
	Str() { m_pStr = new _str; }		//если не копи€, то создаем
	Str(const char* p) {		// новый ресурс
		m_pStr = new _str(p);
	}
	~Str() {
		m_pStr->Release(); 	// Ќе уничтожаем ресурс!
	}				// ”меньшаем счетчик ссылок!

	int len() const {
		return strlen(m_pStr->m_pszData);
	}

    int find(const char* t, int off) const {
        int n = len();
        int m = strlen(t);
        for (int i = off; i <= n - m; i++) {
            int j;
            for (j = 0; j < m; j++) {
                if (m_pStr->m_pszData[i + j] != t[j]) {
                    break;
                }
            }
            if (j == m) {
                return i;
            }
        }
        return -1;
    }

};
        //a.≈сли искать пустую строку, то метод вернет - 1, так как пуста€ строка не может быть найдена в другой строке.

        //b.≈сли имеетс€ 2 вхождени€ образца, то метод вернет индекс первого вхождени€.ƒл€ поиска всех вхождений нужно вызвать метод несколько раз сначала с off = 0, потом с off = найденный_индекс + 1.

        //c.ѕараметр off указывает, с какой позиции начать поиск.≈сли off меньше 0 или больше или равен длине строки, то поиск начнетс€ с начала строки(off = 0).ѕоэтому он обрабатываетс€ правильно.

        //d.≈сли искомый образец совпадает с окончанием исходной строки, то метод вернет индекс, соответствующий началу последнего вхождени€ образца в строке.≈сли искомый образец совпадает с пустой строкой, то метод всегда будет возвращать - 1, так как пуста€ строка не может быть найдена в другой строке.
